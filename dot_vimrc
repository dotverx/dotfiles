let mapleader = " "
let maplocalleader = " "
" prevent space from doing anything in normal/visual/operator-pending
nnoremap <space> <nop>
xnoremap <space> <nop>
onoremap <space> <nop>

set encoding=utf-8

set list
set listchars=tab:>\|,trail:\|,lead:\|,nbsp:\|,precedes:<,extends:>
set smartindent
set smarttab
set autoindent
set copyindent
set preserveindent
set expandtab
set tabstop=4
set softtabstop=4
set shiftwidth=4
set shiftround
set splitbelow
set splitright
set virtualedit=block
set wrap
set linebreak
set breakindent

set formatoptions+=j
set formatoptions+=n
set hidden
set autoread
set confirm

set scrolloff=2
set sidescrolloff=2

set ignorecase
set smartcase
set hlsearch
set incsearch
set wildignorecase

set showtabline=2

set showmatch

set updatetime=300
set ttimeout
set ttimeoutlen=10

set cursorline
set number
set relativenumber

" tree style
let g:netrw_liststyle=3
let g:netrw_banner=0
" open file by reusing the same (netrw) window
let g:netrw_browse_split=0
" splits open on the right
let g:netrw_altv=1
" show line numbers change default nonu to nu
let g:netrw_bufsettings = 'noma nomod nu nowrap ro nobl'

" search list for find, etc.
" . directory of the buffer's file location
" <empty between commas> current working directory (pwd)
" ** recurse into subdirectories
set path=.,,**

if has ('clipboard')
    set clipboard=unnamedplus
else
    echo '.vimrc: clipboard not available'
endif

if has ('termguicolors')
    set termguicolors
    colorscheme habamax
else
    echo '.vimrc: termguicolors not available'
    colorscheme pablo
endif

if has('persistent_undo')
    let s:candidates = []
    " the first candidate will become the undodir
    if exists('$XDG_CACHE_HOME') && !empty($XDG_CACHE_HOME)
        call add(s:candidates, $XDG_CACHE_HOME . '/vim/undo')
    endif
    if exists('$HOME') && !empty($HOME)
        call add(s:candidates, $HOME . '/.cache/vim/undo')
    endif
    if exists('$TEMP') && !empty($TEMP)
        call add(s:candidates, $TEMP . '/vim-undo')
    endif
    let s:undodir = ''
    for s:dir in s:candidates
        let s:dir = expand(s:dir)
        if !isdirectory(s:dir)
            call mkdir(s:dir, 'p')
        endif
        call setfperm(s:dir, 'rwx------')
        if getftype(s:dir) ==# 'dir' && getfperm(s:dir) ==# 'rwx------'
            let s:undodir = s:dir
            break
        endif
    endfor
    if empty(s:undodir)
        " no dir with permissions 0700
        set noundofile
        echo '.vimrc: undodir not available'
    else
        let &undodir = s:undodir
        set undofile
    endif
else
    echo '.vimrc: persistent_undo not available'
endif

filetype plugin indent on


let s:plugins_enabled = v:true
if s:plugins_enabled
" ===============
" === plugins ===
" ===============
" <begin_config>

" to disable a plugin comment it out here
call plug#begin()
Plug 'tpope/vim-commentary'
Plug 'neoclide/coc.nvim', {'branch': 'release'}
Plug 'mbbill/undotree'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'moll/vim-bbye'
Plug 'psliwka/vim-smoothie'
call plug#end()


" plugin is declared in plug.vim
function! s:DeclaredPlug(name)
  return exists('g:plugs') && has_key(g:plugs, a:name)
endfunction

" plugin is stored on disk
function! s:RtpHas(relpath) abort
  return !empty(globpath(&runtimepath, a:relpath))
endfunction

" plugin is loaded and a cmd is available
function! s:CmdExists(cmd) abort
  return exists(':' . a:cmd) == 2
endfunction

function! s:PluginAvailable(name, relpath, cmd)
  return s:DeclaredPlug(a:name) && (s:RtpHas(a:relpath) || s:CmdExists(a:cmd))
endfunction


if s:PluginAvailable('vim-commentary', 'plugin/commentary.vim', 'Commentary')
" ======================
" === commentary.vim ===
" ======================
" <begin_config>

" use the default 'gc' to comment

" <end_config>
" ======================
" === commentary.vim ===
" ======================
else
  echo '.vimrc: commentary not configured'
endif


if s:PluginAvailable('coc.nvim', 'plugin/coc.vim', 'CocInfo')
" ================
" === COC.NVIM ===
" ================
" <begin_config>

let g:coc_global_extensions = [
    \ 'coc-diagnostic',
    \ 'coc-docker',
    \ 'coc-go',
    \ 'coc-java',
    \ 'coc-json',
    \ 'coc-lua',
    \ 'coc-pyright',
    \ 'coc-sh',
    \ 'coc-vimlsp',
    \ 'coc-yank',
    \ 'coc-yaml',
    \ ]

" Dockerfile
" - LSP:        coc-docker
" - linting:    hadolint via coc-diagnostic
" - formatting: dockerfmt via coc-diagnostic
" Golang:
" - LSP:        TODO
" - linting:    TODO
" - formatting: TODO
" Java
" - LSP:        TODO
" - linting:    TODO
" - formatting: TODO
" JSON
" - schemas:    coc-json
" - formatting: TODO
" Lua
" - LSP:        TODO
" - linting:    TODO
" - formatting: TODO
" Python
" - LSP:        coc-pyright
" - linting:    ruff via coc-pyright
" - formatting: black and ruff (imports organizing) via coc-pyright
" Shell
" - LSP:        coc-sh
" - linting:    shellcheck via coc-sh
" - formatting: shfmt via coc-sh
" VimScript:
" - LSP:        coc-vimlsp
" - linting:    vint via coc-diagnostic
" - formatting: -
" TOML:
" - LSP:        TODO
" - linting:    TODO
" - formatting: TODO
" XML:
" - LSP:        TODO
" - linting:    TODO
" - formatting: TODO
" YAML
" - schemas:    coc-yaml
" - linting:    yamllint via coc-diagnostic
" - formatting: TODO

" https://raw.githubusercontent.com/neoclide/coc.nvim/master/doc/coc-example-config.vim

" Some servers have issues with backup files, see #649
set nobackup
set nowritebackup

" Always show the signcolumn, otherwise it would shift the text each time
" diagnostics appear/become resolved
set signcolumn=yes

inoremap <silent><expr> <C-n> coc#pum#visible() ? coc#pum#next(1) : coc#refresh()
inoremap <silent><expr> <C-p> coc#pum#visible() ? coc#pum#prev(1) : coc#refresh()

if has('nvim-0.4.0') || has('patch-8.2.0750')
  nnoremap <silent><nowait><expr> <f3> coc#float#has_scroll() ? coc#float#scroll(1) : "\<f3>"
  nnoremap <silent><nowait><expr> <f4> coc#float#has_scroll() ? coc#float#scroll(0) : "\<f4>"
  inoremap <silent><nowait><expr> <f3> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(1)\<cr>" : "\<f3>"
  inoremap <silent><nowait><expr> <f4> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(0)\<cr>" : "\<f4>"
  vnoremap <silent><nowait><expr> <f3> coc#float#has_scroll() ? coc#float#scroll(1) : "\<f3>"
  vnoremap <silent><nowait><expr> <f4> coc#float#has_scroll() ? coc#float#scroll(0) : "\<f4>"
endif

nmap <silent> <leader>ln <plug>(coc-diagnostic-next)
nmap <silent> <leader>lp <plug>(coc-diagnostic-prev)
nmap <silent> <leader>ld <plug>(coc-definition)
nmap <silent> <leader>lD <plug>(coc-type-definition)
nmap <silent> <leader>li <plug>(coc-implementation)
nmap <silent> <leader>lr <plug>(coc-references)
nmap <leader>lR <plug>(coc-rename)
xmap <leader>lf <plug>(coc-format-selected)
nmap <leader>lf <plug>(coc-format-selected)
nmap <leader>lF <plug>(coc-format)
xmap <leader>la <plug>(coc-codeaction-selected)
nmap <leader>la <plug>(coc-codeaction-cursor)
nmap <leader>lA <plug>(coc-codeaction-source)
nmap <leader>lq <plug>(coc-fix-current)
nnoremap <silent> <leader>lh :call ShowDocumentation()<cr>
nnoremap <silent> <leader>lH <Plug>(coc-float-hide)
nmap <silent> <leader>lre <plug>(coc-codeaction-refactor)
xmap <silent> <leader>lrs <plug>(coc-codeaction-refactor-selected)
nmap <silent> <leader>lrs <plug>(coc-codeaction-refactor-selected)
nmap <leader>lL <plug>(coc-codelens-action)
nmap <silent> <leader>lv <plug>(coc-range-select)
xmap <silent> <leader>lv <plug>(coc-range-select)

nnoremap <silent><nowait> <leader>cd :<c-u>coclist diagnostics<cr>
nnoremap <silent><nowait> <leader>ce :<c-u>coclist extensions<cr>
nnoremap <silent><nowait> <leader>cc :<c-u>coclist commands<cr>
nnoremap <silent><nowait> <leader>co :<c-u>coclist outline<cr>
nnoremap <silent><nowait> <leader>cs :<c-u>coclist -i symbols<cr>
nnoremap <silent><nowait> <leader>cj :<c-u>cocnext<cr>
nnoremap <silent><nowait> <leader>ck :<c-u>cocprev<cr>
nnoremap <silent><nowait> <leader>cp :<c-u>coclistresume<cr>

xmap if <plug>(coc-funcobj-i)
omap if <plug>(coc-funcobj-i)
xmap af <plug>(coc-funcobj-a)
omap af <plug>(coc-funcobj-a)
xmap ic <plug>(coc-classobj-i)
omap ic <plug>(coc-classobj-i)
xmap ac <plug>(coc-classobj-a)
omap ac <plug>(coc-classobj-a)

function! ShowDocumentation()
  if CocAction('hasProvider', 'hover')
    call CocActionAsync('doHover')
  else
    call feedkeys('K', 'in')
  endif
endfunction

autocmd CursorHold * silent call CocActionAsync('highlight')

" expression that runs for gq (format operator)
augroup mygroup
  autocmd!
  autocmd FileType * setlocal formatexpr=CocAction('formatSelected')
augroup end

" format current buffer
command! -nargs=0 Format :call CocActionAsync('format')

" fold current buffer
command! -nargs=? Fold :call CocAction('fold', <f-args>)

" organize imports of the current buffer
command! -nargs=0 OR :call CocActionAsync('runCommand', 'editor.action.organizeImport')

" Add (Neo)Vim's native statusline support
" NOTE: Please see `:h coc-status` for integrations with external plugins that
" provide custom statusline: lightline.vim, vim-airline
set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}

" <end_config>
" ================
" === COC.NVIM ===
" ================
else
  echo '.vimrc: coc.nvim not configured'
endif


" if s:CmdExists('UndotreeToggle') || s:RtpHas('plugin/undotree.vim')
if s:PluginAvailable('undotree', 'plugin/undotree.vim', 'UndotreeToggle')
" ================
" === undotree ===
" ================
" <begin_config>

nnoremap <F5> :UndotreeToggle<CR>

" <end_config>
" ================
" === undotree ===
" ================
else
  echo '.vimrc: undotree not configured'
endif


if s:PluginAvailable('vim-airline', 'plugin/airline.vim', 'AirlineToggle')
" ==================
" === vim-airline ===
" ==================
" <begin_config>

let g:airline_theme='distinguished'

let g:airline#extensions#tabline#enabled=1
let g:airline#extensions#tabline#formatter='unique_tail_improved'
let g:airline#extensions#tabline#show_buffers=1
let g:airline#extensions#tabline#show_tabs=1

" disable showing current mode in cmd line
set noshowmode

" <end_config>
" ==================
" === vim-airline ===
" ==================
else
  echo '.vimrc: vim-airline not configured'
endif


if s:PluginAvailable('vim-bbye', 'plugin/bbye.vim', 'Bdelete')
" ================
" === vim-bbye ===
" ================
" <begin_config>

" :Bw   -> :Bwipeout
" :Bw!  -> :Bwipeout!
command! -bang Bw Bwipeout<bang>

" :Bd   -> :Bdelete
" :Bd!  -> :Bdelete!
command! -bang Bd Bdelete<bang>

" <end_config>
" ================
" === vim-bbye ===
" ================
else
  echo '.vimrc: bbye not configured'
endif


if s:PluginAvailable('vim-smoothie', 'plugin/smoothie.vim', '')
" ====================
" === vim-smoothie ===
" ====================
" <begin_config>

" use to enable/disable
" let g:smoothie_enabled=1

" vim-smoothie overrides the following:
" '<C-D>'
" '<C-U>'
" '<C-F>'
" '<S-Down>'
" '<PageDown>'
" '<C-B>'
" '<S-Up>'
" '<PageUp>'
" 'z+'
" 'z^'
" 'zt'
" 'z<CR>'
" 'z.'
" 'zz'
" 'z-'
" 'zb'
" use to prevent overriding the defaults
" let g:smoothie_no_default_mappings=1

" <end_config>
" ====================
" === vim-smoothie ===
" ====================
else
  echo '.vimrc: smoothie not configured'
endif

" <end_config>
" ===============
" === plugins ===
" ===============
endif "s:plugins_enabled

